import { NextRequest, NextResponse } from "next/server";
import { USE_SUPABASE } from "@/lib/config";

export async function GET(request: NextRequest) {
  const tenantId = request.nextUrl.searchParams.get("tenantId");
  const range = request.nextUrl.searchParams.get("range") || "all";

  if (!tenantId) {
    return NextResponse.json({ error: "Tenant ID required" }, { status: 400 });
  }

  // Local mode - return empty analytics
  if (!USE_SUPABASE || tenantId === "local") {
    return NextResponse.json({
      importedVideos: 0,
      totalChats: 0,
      totalMessages: 0,
      totalNotes: 0,
      popularTopics: [],
      recentActivity: [],
      contentGenerated: {
        summaries: 0,
        descriptions: 0,
        newsletters: 0,
        quotes: 0,
        highlights: 0,
      },
    });
  }

  // Supabase mode
  try {
    const { supabase } = await import("@/lib/supabase");

    // Calculate date range based on filter
    const now = new Date();
    let startDate: Date | null = null;

    switch (range) {
      case "today":
        startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        break;
      case "week":
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case "month":
        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      case "year":
        startDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
        break;
      case "all":
      default:
        startDate = null;
        break;
    }

    // Fetch imported videos count (only videos with transcripts imported)
    // Use updated_at for date filter since that reflects when the import happened
    let videosQuery = supabase
      .from("videos")
      .select("id, title, created_at, updated_at, ai_analysis", { count: "exact" })
      .eq("tenant_id", tenantId)
      .eq("is_imported", true);

    if (startDate) {
      // Filter by updated_at which is when the video was imported (is_imported set to true)
      videosQuery = videosQuery.gte("updated_at", startDate.toISOString());
    }

    const { data: videos, count: importedVideos } = await videosQuery;

    // Fetch messages count with date filter
    let messagesQuery = supabase
      .from("video_messages")
      .select("id, created_at", { count: "exact" })
      .eq("tenant_id", tenantId);

    if (startDate) {
      messagesQuery = messagesQuery.gte("created_at", startDate.toISOString());
    }

    const { count: totalMessages } = await messagesQuery;

    // Fetch notes with types and date filter
    let notesQuery = supabase
      .from("video_notes")
      .select("id, type, title, created_at", { count: "exact" })
      .eq("tenant_id", tenantId);

    if (startDate) {
      notesQuery = notesQuery.gte("created_at", startDate.toISOString());
    }

    const { data: notes, count: totalNotes } = await notesQuery;

    // Calculate content generated by type
    const contentGenerated = {
      summaries: notes?.filter((n) => n.type === "summary").length || 0,
      descriptions: notes?.filter((n) => n.type === "description").length || 0,
      newsletters: notes?.filter((n) => n.type === "newsletter").length || 0,
      quotes: notes?.filter((n) => n.type === "quotes").length || 0,
      highlights: notes?.filter((n) => n.type === "highlights").length || 0,
    };

    // Calculate unique chat sessions with date filter
    let chatQuery = supabase
      .from("video_messages")
      .select("created_at")
      .eq("tenant_id", tenantId)
      .eq("role", "user");

    if (startDate) {
      chatQuery = chatQuery.gte("created_at", startDate.toISOString());
    }

    const { data: chatMessages } = await chatQuery;
    const chatDates = new Set(
      chatMessages?.map((m) => new Date(m.created_at).toDateString()) || []
    );
    const totalChats = chatDates.size;

    // Extract popular topics from video AI analysis (filtered videos)
    const topicCounts: Record<string, number> = {};
    videos?.forEach((video) => {
      const analysis = video.ai_analysis;
      if (analysis?.topicTags) {
        analysis.topicTags.forEach((tag: { name: string }) => {
          topicCounts[tag.name] = (topicCounts[tag.name] || 0) + 1;
        });
      } else if (analysis?.topics) {
        analysis.topics.forEach((topic: string) => {
          topicCounts[topic] = (topicCounts[topic] || 0) + 1;
        });
      }
    });

    const popularTopics = Object.entries(topicCounts)
      .map(([name, count]) => ({ name, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    // Build recent activity from filtered data
    const recentActivity: { type: string; title: string; date: string; timestamp: number }[] = [];

    // Add recent videos (use updated_at which reflects import date)
    videos?.forEach((video) => {
      const importDate = video.updated_at || video.created_at;
      recentActivity.push({
        type: "video",
        title: `Imported: ${video.title}`,
        date: formatRelativeDate(new Date(importDate)),
        timestamp: new Date(importDate).getTime(),
      });
    });

    // Add recent notes
    notes?.forEach((note) => {
      recentActivity.push({
        type: "note",
        title: `Created ${note.type}: ${note.title}`,
        date: formatRelativeDate(new Date(note.created_at)),
        timestamp: new Date(note.created_at).getTime(),
      });
    });

    // Sort by timestamp descending and take top 8
    recentActivity.sort((a, b) => b.timestamp - a.timestamp);
    const topActivity = recentActivity.slice(0, 8).map(({ type, title, date }) => ({
      type,
      title,
      date,
    }));

    return NextResponse.json({
      importedVideos: importedVideos || 0,
      totalChats,
      totalMessages: totalMessages || 0,
      totalNotes: totalNotes || 0,
      popularTopics,
      recentActivity: topActivity,
      contentGenerated,
    });
  } catch (error) {
    console.error("Analytics fetch error:", error);
    return NextResponse.json({ error: "Failed to fetch analytics" }, { status: 500 });
  }
}

function formatRelativeDate(date: Date): string {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / (1000 * 60));
  const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

  if (diffMins < 1) return "Just now";
  if (diffMins < 60) return `${diffMins}m ago`;
  if (diffHours < 24) return `${diffHours}h ago`;
  if (diffDays < 7) return `${diffDays}d ago`;

  return date.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
  });
}
