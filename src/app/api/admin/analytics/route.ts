import { NextRequest, NextResponse } from "next/server";
import { USE_SUPABASE } from "@/lib/config";

export async function GET(request: NextRequest) {
  const tenantId = request.nextUrl.searchParams.get("tenantId");
  const range = request.nextUrl.searchParams.get("range") || "month";

  if (!tenantId) {
    return NextResponse.json({ error: "Tenant ID required" }, { status: 400 });
  }

  // Local mode - return empty analytics
  if (!USE_SUPABASE || tenantId === "local") {
    return NextResponse.json({
      totalVideos: 0,
      totalChats: 0,
      totalMessages: 0,
      totalNotes: 0,
      videosThisMonth: 0,
      chatsThisWeek: 0,
      popularTopics: [],
      recentActivity: [],
      contentGenerated: {
        summaries: 0,
        descriptions: 0,
        newsletters: 0,
        quotes: 0,
        highlights: 0,
      },
    });
  }

  // Supabase mode
  try {
    const { supabase } = await import("@/lib/supabase");

    // Calculate date ranges
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    let startDate: Date | null = null;
    if (range === "week") {
      startDate = weekAgo;
    } else if (range === "month") {
      startDate = monthAgo;
    }

    // Fetch videos count
    const videosQuery = supabase
      .from("videos")
      .select("id, title, created_at, ai_analysis", { count: "exact" })
      .eq("tenant_id", tenantId);

    const { data: videos, count: totalVideos } = await videosQuery;

    // Count videos this month
    const videosThisMonth = videos?.filter(
      (v) => new Date(v.created_at) > monthAgo
    ).length || 0;

    // Fetch messages count
    const messagesQuery = supabase
      .from("video_messages")
      .select("id, created_at", { count: "exact" })
      .eq("tenant_id", tenantId);

    if (startDate) {
      messagesQuery.gte("created_at", startDate.toISOString());
    }

    const { count: totalMessages } = await messagesQuery;

    // Fetch notes with types
    const notesQuery = supabase
      .from("video_notes")
      .select("id, type, title, created_at", { count: "exact" })
      .eq("tenant_id", tenantId);

    if (startDate) {
      notesQuery.gte("created_at", startDate.toISOString());
    }

    const { data: notes, count: totalNotes } = await notesQuery;

    // Calculate content generated by type
    const contentGenerated = {
      summaries: notes?.filter((n) => n.type === "summary").length || 0,
      descriptions: notes?.filter((n) => n.type === "description").length || 0,
      newsletters: notes?.filter((n) => n.type === "newsletter").length || 0,
      quotes: notes?.filter((n) => n.type === "quotes").length || 0,
      highlights: notes?.filter((n) => n.type === "highlights").length || 0,
    };

    // Calculate unique chat sessions (approximate by counting distinct days with messages)
    const chatDates = new Set(
      (await supabase
        .from("video_messages")
        .select("created_at")
        .eq("tenant_id", tenantId)
        .eq("role", "user")
      ).data?.map((m) => new Date(m.created_at).toDateString()) || []
    );

    const totalChats = chatDates.size;
    const chatsThisWeek = Array.from(chatDates).filter(
      (d) => new Date(d) > weekAgo
    ).length;

    // Extract popular topics from video AI analysis
    const topicCounts: Record<string, number> = {};
    videos?.forEach((video) => {
      const analysis = video.ai_analysis;
      if (analysis?.topicTags) {
        analysis.topicTags.forEach((tag: { name: string }) => {
          topicCounts[tag.name] = (topicCounts[tag.name] || 0) + 1;
        });
      } else if (analysis?.topics) {
        analysis.topics.forEach((topic: string) => {
          topicCounts[topic] = (topicCounts[topic] || 0) + 1;
        });
      }
    });

    const popularTopics = Object.entries(topicCounts)
      .map(([name, count]) => ({ name, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    // Build recent activity
    const recentActivity: { type: string; title: string; date: string }[] = [];

    // Add recent videos
    videos
      ?.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())
      .slice(0, 5)
      .forEach((video) => {
        recentActivity.push({
          type: "video",
          title: `Imported: ${video.title}`,
          date: formatRelativeDate(new Date(video.created_at)),
        });
      });

    // Add recent notes
    notes
      ?.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())
      .slice(0, 5)
      .forEach((note) => {
        recentActivity.push({
          type: "note",
          title: `Created ${note.type}: ${note.title}`,
          date: formatRelativeDate(new Date(note.created_at)),
        });
      });

    // Sort all activity by most recent
    recentActivity.sort((a, b) => {
      // Simple sorting - real implementation would parse dates
      return 0;
    });

    return NextResponse.json({
      totalVideos: totalVideos || 0,
      totalChats,
      totalMessages: totalMessages || 0,
      totalNotes: totalNotes || 0,
      videosThisMonth,
      chatsThisWeek,
      popularTopics,
      recentActivity: recentActivity.slice(0, 8),
      contentGenerated,
    });
  } catch (error) {
    console.error("Analytics fetch error:", error);
    return NextResponse.json({ error: "Failed to fetch analytics" }, { status: 500 });
  }
}

function formatRelativeDate(date: Date): string {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / (1000 * 60));
  const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

  if (diffMins < 1) return "Just now";
  if (diffMins < 60) return `${diffMins}m ago`;
  if (diffHours < 24) return `${diffHours}h ago`;
  if (diffDays < 7) return `${diffDays}d ago`;

  return date.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
  });
}
